i2c code to show i tried
lcd.h: 


// #define SLAVE_ADDR 0x43
// volatile uint8_t i2c_idle_counter = 0;
// #define I2C_IDLE_TIMEOUT 5  // 2 seconds


// void i2c_init_slave(void) {
//     // Set P1.2 (SDA) and P1.3 (SCL) for I2C functionality
//     P1SEL0 |= BIT2 | BIT3;
//     P1SEL1 &= ~(BIT2 | BIT3);

//     P1REN |= BIT2 | BIT3;  // Enable resistor on P1.2 (SDA) and P1.3 (SCL)
//     P1OUT |= BIT2 | BIT3;  // Set as pull-up


//     // Put eUSCI_B0 into reset
//     UCB0CTLW0 = UCSWRST;

//     // I2C mode, synchronous
//     UCB0CTLW0 |= UCMODE_3 | UCSYNC;

//     // 7-bit slave address
//     UCB0I2COA0 = SLAVE_ADDR | UCOAEN;

//     // Clear reset to start operation
//     UCB0CTLW0 &= ~UCSWRST;

//     // Enable I2C interrupts
//     UCB0IE |= UCRXIE0 | UCSTPIE | UCNACKIE;
// }



main.c:

//i2c_init_slave();
//__enable_interrupt();


// // I2C
// #pragma vector = USCI_B0_VECTOR
// __interrupt void USCI_B0_ISR(void) {
//     switch (__even_in_range(UCB0IV, USCI_I2C_UCBIT9IFG)) {
//         case USCI_I2C_UCRXIFG0: {
//             uint8_t received = UCB0RXBUF;

//             // Reset inactivity timer + turn on status LED
//             i2c_idle_counter = 0;
//             P1OUT |= BIT4;

//             // Use recieved byte to select pattern
//             if (received == 0x01) {
//                 key_input('1');
//             } 
//             else if (received == 0x02) {
//                 key_input('2');
//             } 
//             else if (received == 0x03) {
//                 key_input('3');
//             }
//             else if (received == 0x04) {
//                 key_input('4');
//             }
//             else if (received == 0x05) {
//                 key_input('5');
//             }
//             else if (received == 0x06) {
//                 key_input('6');
//             }
//             else if (received == 0x07) {
//                 key_input('7');
//             }
//             else if (received == 0x08) {
//                 key_input('8');
//             }
//             else if (received == 0x09) {
//                 key_input('9');
//             }
//             else if (received == 0x00) {
//                 key_input('0');
//             }
//             else if (received == 'A') {
//                 key_input('A');
//             }
//             else if (received == 'B') {
//                 key_input('B');
//             }
//             else if (received == 'C') {
//                 key_input('C');
//             }
//             else if (received == 'D') {
//                 key_input('D');
//             }
//             else if (received == '#') {
//                 key_input('#');
//             }
//             else if (received == '*') {
//                 key_input('*');
//             }

//             break;
//         }
        
//         case USCI_I2C_UCSTPIFG: {
//             // Stop condition recieved
//             UCB0IFG &= ~UCSTPIFG;
//             break;
//         }

//         case USCI_I2C_UCNACKIFG: {
//             // NACK handling (just in case)
//             UCB0CTLW0 |= UCTXNACK;
//             break;
//         }

//         default:
//             break;
//     }
// }
